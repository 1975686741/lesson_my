# Promise

- Promise是ES6新增的引用类型，JavaScript 中用于处理异步操作的一种编程模式，它用于处理那些可能在未来完成的操作，例如从服务器获取数据、读取文件、执行数据库查询等。Promise 提供了一种更优雅、更可靠的方式来处理异步操作，避免了回调地狱（callback hell）的问题，使异步代码更加清晰、易于理解和维护。
- Promise有三种状态：
    - Pending（进行中）：初始状态，表示异步操作还没有完成；
    - Fulfilled（已完成）：表示异步操作成功完成，并返回了一个结果值；
    - Rejected（已拒绝）：表示异步操作失败或被拒绝，并返回了一个错误原因。
- 更可靠的错误处理：Promise 提供了 .catch() 方法来捕获异步操作中产生的错误，并进行处理。
- 更好的链式调用：Promise 可以通过 .then() 方法进行链式调用，使多个异步操作按照特定的顺序依次执行，避免了回调地狱的问题。
  
- Promise 的实现原理，你可以从以下几个方面进行回答：
Promise 的构造函数接受一个函数作为参数，该函数包含异步操作的逻辑，并且接受两个参数：resolve 和 reject，分别用于异步操作成功和失败时的回调函数。
Promise 的 then 方法可以接受两个回调函数作为参数，第一个回调函数处理异步操作成功的结果，第二个回调函数处理异步操作失败的结果。
Promise 内部通过一个状态机来控制异步操作的状态，状态转换规则如下：
Promise 初始状态为 Pending；
如果异步操作成功，调用 resolve 函数并将 Promise 状态改为 Fulfilled；
如果异步操作失败，调用 reject 函数并将 Promise 状态改为 Rejected；
Promise 一旦进入 Fulfilled 或 Rejected 状态，就无法再次改变。

Promise.all/race/any/allSettled(所有的p对象都结束才结束，返回status +valus/reason)/finally(结束时不管成功失败都执行回调)  返回一个promise实例
    - finally 有什么用 
        - 大型语言 try{} catch(){}  finally
        1. 不管成功失败，都要有执行结果，就用finally  不会改变promise的状态
        2. 有些应用不只是耗时
              1. I/O操作要关闭句柄...
Promise then  第二个参数 和catch的区别
    - catch
          .then(() => {}, (reson) => {

          })  链式调用更简洁  

- 如何判断一个对象为Promise对象
*  instanceOf
* 使用Promise.resolve()方法判断 
传入的参数转换为Promise对象，如果参数本身就是Promise对象，则直接返回该对象。
* 判断对象是否具有then方法

- 最后，你可以结合实际项目经验，讲解你是如何使用 Promise 解决具体的异步编程问题的，例如：
在前端项目中使用 Promise 处理 Ajax 请求；
在 Node.js 项目中使用 Promise 处理文件读写、数据库操作等异步操作；
使用 Promise 实现异步代码的流程控制和数据处理等功能。   

# 介绍一下HTTP状态码  相应的场景
    - 1XX  消息状态码
        - 100：Continue 继续。客户端应继续其请求。
        - 101：Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。
    - 2XX  成功
        - 200：OK 请求成功。一般用于 GET 与 POST 请求。
        - 201：Created 已创建。成功请求并创建了新的资源。
        - 202：Accepted 已接受。已经接受请求，但未处理完成。
        - 203：Non-Authoritative Information    非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本。
        - 204：No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。
        - 205：Reset Content    重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域。
        - 206：Partial Content     部分内容。服务器成功处理了部分 GET 请求
    - 3XX  跳转/重定向状态码
        - 300：Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
        - 301：Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。
        - 302：Found 临时移动，与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI。
        - 303：See Other    查看其它地址。与 301 类似。使用 GET 和 POST 请求查看。
        - 304：Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
    - 4XX  用户端/客户端出错
        - 400 Bad Request  客户端请求的语法错误/用户没有按要求完成，服务器无法理解。 | 用户名错误
        - 401 Unauthorized 请求要求用户的身份认证  | 未登录
        - 402：Payment Required 保留，将来使用。
        - 403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。| 登录了但没权限
        - 404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面。
        - 405：Method Not Allowed 客户端请求中的方法被禁止。
        - 409：Confilt  冲突，服务器处理请求时发生了冲突 | 注册时，用户名别人注册了
    - 5XX  服务器端出错
        - 500：Internal Server Error 服务器内部错误，无法完成请求。

# http 和 https 的区别及优缺点？
	1. http 是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的超文本传输协议。
	2. https 是以安全为目标的HTTP通道，即HTTP下 加入SLL层进行加密。 作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
http 协议的默认端口为 80，https 的默认端口为 443。
http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
https 缓存不如 http 高效，会增加数据开销。
Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗

# TCP和UDP的区别
	* TCP是面向连接的；而UDP是面向无连接的
	* TCP仅支持单播传输，客户端到服务器端单向传输；而UDP提供了单播，多播、广播的功能
	* TCP的三次握手保证了连接的可靠性；UDP是无连接的、不可靠的一种数据传输协议，通信对不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收
	* UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好

# vue2和vue3的区别
    - 生态系统方面的区别：
Vue 2 拥有成熟的生态系统，有大量的插件、组件库和工具可供使用。
Vue 3 的生态系统正在迅速发展中，一些 Vue 2 的插件和组件库正在逐步迁移到 Vue 3 上。
    - setup 语法糖 + Composition API: 与 Vue 2 的选项式 API 相比，组合式 API 允许将相关的功能更紧密地组织在一起，把代码更好地聚合在一起 & 逻辑重用,提高了代码的可读性和可维护性。
    - 静态树和静态属性提升：Vue 3 在编译阶段进行了静态树和静态属性提升的优化。这意味着 Vue 3 可以在编译时确定哪些部分是静态的，从而避免了不必要的渲染和更新，提高了性能。
    - 更好的 TypeScript 支持：Vue 3 的源代码使用 TypeScript 编写，这意味着 Vue 3 与 TypeScript 的集成更加紧密，提供了更好的类型推断和类型安全。
    - 多个根元素：Vue 3 允许在组件模板中使用多个根元素，不再需要一个包裹元素。这可以减少不必要的 DOM 结构，提高代码的可读性。
    - 响应式系统：Vue 2 的响应式系统使用了 Object.defineProperty 来劫持数据的访问和修改，而 Vue 3 使用了 ES6 的 Proxy 对象实现响应式系统，Proxy 对象可以捕获到更多的操作，如属性的删除和新增，从而实现更全面的响应式追踪。，提供了更高效和灵活的数据劫持机制。
    -  源码架构：Vue 2 的源码采用的是 monolithic（单体）架构，整个源码都集中在一个代码库中。而 Vue 3 的源码采用的是 monorepo（多库）架构，将不同功能模块拆分成独立的代码库，例如 runtime-core、reactivity、compiler 等。
    -  Tree-shaking：Vue 3 的核心库被设计为可 Tree-shaking，这意味着只有使用到的功能会被打包，未使用的功能会被移除，最终产出的代码更小。
    -  编译器：Vue 2 的编译器将模板转换为渲染函数，而 Vue 3 的编译器进行了重写，采用了基于插槽的中间表示（Slot-based IR），可以更好地处理模板中的动态内容和编译优化。
    -  编译模式：Vue 3 默认采用了运行时编译（Runtime Compilation）模式，而 Vue 2 默认使用的是模板编译（Template Compilation）模式。这使得 Vue 3 的构建体积更小，性能更高，同时提供了更好的开发体验。
    -  VNode 类型：Vue 2 和 Vue 3 的虚拟节点（VNode）类型略有不同。Vue 2 中的 VNode 类型是树状结构的，而 Vue 3 引入了 Fragment 和 Portal，支持更灵活的渲染方式。
    -  虚拟DOM：Vue 3 的虚拟 DOM 引入了 PatchFlag 的概念，更准确地标记节点的特性和变化，以优化 diff 算法的性能。
    -  diff算法：包括更高效的算法实现、减少不必要的遍历和计算、更精简的内部逻辑等，提升了整体的运行效率。Vue 2 和 Vue 3 在处理列表渲染时都需要使用 key 属性来标识节点的唯一性，以便进行更精确的 diff。然而，Vue 3 在对列表进行 diff 过程中采用了更高效的算法，通过使用动态规划的方式来计算最长递增子序列（LIS）来匹配和重排节点，减少了不必要的移动和操作。
