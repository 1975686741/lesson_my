
# Vue-Router 哪几种方案，原理是什么？   
    - URL改变，但页面无需刷新，SPA单页应用，优化了体验
      - 传统的基于后端路由，访问请求，会白屏，重新请求
      - 动态修改页面
    1. Hash模式
      - 使用URL的哈希部分（#后面的部分）来模拟路由。当URL中的哈希值发生变化时（HashChange事件），Vue-Router会根据哈希值的变化来匹配对应的路由，并进行页面更新。
      - 优点：兼容性好，可以支持不同浏览器和服务器环境。
      - 缺点：URL中含有冗余的#字符，不够美观。
    2. History模式
      - 使用HTML5的History API，在不刷新整个页面的情况下改变URL，实现路由切换效果。通过使用pushState或replaceState方法来修改URL，同时使用popstate事件来监听URL的变化，订阅发布者模式。
      - 优点：URL更加美观，没有冗余的#字符。
      - 缺点：需要服务器端配置支持，否则在刷新页面时会导致404错误。兼容性较差。
    3. Abstract模式
      - 在非浏览器环境中使用，例如在服务器端渲染（SSR）或原生移动应用中。不会直接操作URL，而是将路由状态保存在内存中，并通过调用相应的方法来实现路由切换和页面渲染。
      - 优点：适用于非浏览器环境，不依赖URL。
      - 缺点：不支持直接访问特定路由。
    
# vue修饰符
    - 表单修饰符
        - v-model.lazy  v-model.trim v-model.number...
    - 事件修饰符
        - v-on:click.stop  v-on:click.prevent...
        - .passive v-on:scroll.passive 节流
        - .capture  父元素先于子元素触发
        - .self 只有事件是由元素自己触发时才触发对应的事件处理函数，而不是来自子元素的冒泡事件
    - 键盘修饰符
  
# 编写一个focus指令 directive
    ``
            // 指令是会绑定DOM的
        Vue.directive('focus', {
            // 当被绑定的元素插入到DOM中时。。
            inserted: function(el) {
                el.focus();
            }
        })
        <input v-focus />
    ``

# 点击回到顶部
    - 锚链接
        <body>
            <div id="top"></div>
        <a href="#top">回到顶部</a>
    - js
        window.scrollTo({
            top:0,
            behavior: 'smooth'  // 平滑滚动效果
        })

# html input 如何实现上传多个文件
    <input type="file" multiple>

# display 有哪些值？
    - 盒子的默认行为
        - inline  block  inline-block(会有小间隙，设置父元素font-size=0)
    - 常用布局方案 flex table grid 
    - 离开文档流  none

# 什么是事件委托
    事件委托是一种提高程序性能，降低内存空间的技术手段，它利用了事件冒泡的特性，只需要在某个祖先元素上注册一个事件，就能管理其所有后代元素上同一类型的事件，而不需要给子元素一个一个的注册事件。

# 盒模型
    - 标准盒模型： 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)
    - 怪异盒模型： 一个块的总宽度 = width（既 width 已经包含了 padding 和 border 值）+ margin（左右）

# call，apply，bind
        - call 方法接受一个参数列表，每个参数都需要显式列出并依次传递给函数。
        - apply 方法接受两个参数，第一个参数是要绑定给函数的执行上下文，第二个参数是一个数组或类数组对象，其中包含要作为参数传递给函数的值。
        - bind 方法不立即执行函数，而是返回一个新函数。返回的函数可以稍后调用，并将指定的执行上下文和参数传递给原始函数。

# 浅拷贝和深拷贝

# map和forEach
    - 返回值：
map 方法会返回一个新数组，该数组中的每个元素是执行回调函数后的返回值。
forEach 方法没有返回值，只是对数组的每个元素依次执行指定的回调函数。
    - 使用结果：
map 方法的返回值可以被存储和进一步处理。通常情况下，我们会使用 map 来对数组中的每个元素进行处理，并将处理结果组成一个新的数组。
forEach 方法主要用于迭代数组，执行一些副作用操作（比如打印、修改其他变量等），而不关心返回值。
    - 修改原数组：
map 方法不会改变原始数组，它会创建一个新的数组来存储处理后的结果。
forEach 方法也不会改变原数组，但可以通过回调函数中对元素的操作间接修改原数组。
    - 中断循环：
map 方法会遍历完整个数组，并将每个元素都传递给回调函数进行处理，无法中途跳出循环。
forEach 方法也会遍历完整个数组，无法中途跳出循环。如果需要提前终止循环，可以使用 some 或 every 方法。

    需要处理数组并获得一个新的数组作为结果，可以使用 map 方法；而如果只是简单地对数组进行遍历，进行一些副作用操作，可以使用 forEach 方法。
# 闭包

# 原型和原型链